#!/usr/bin/env perl
use warnings;
use strict;
use Data::Dumper;
use List::MoreUtils qw(any);

my(@Options, $verbose, $mindepth, $noref, $output);
setOptions();

$output or die "Please specify a prefix for output files, eg. --output snps";

my %snp;
my @id;
my $num_snps=0;

for my $prefix (@ARGV) {
  -r "$prefix.bam" or die "can not read BAM file: $prefix.bam";
  open VCF, '<', "$prefix.vcf" or die "can not open VCF file: $prefix.vcf";
  my $id = $prefix;
  $id =~ s{^.*/}{};
  $id =~ s/\.vcf$//;
  push @id, $id;
  while (<VCF>) {
    # CHROM  POS     ID      REF     ALT     QUAL    FILTER  INFO    FORMAT  unknown
    next if m/^#/;
    chomp;
    my($seq,$pos,undef,$ref,$alt) = split m/\t/;
    next unless length($ref)==1 and length($alt)==1;
    $snp{$seq}{$pos}{REF} = $ref;
    $snp{$seq}{$pos}{$id} = $alt;
    $num_snps++;
  }
  close VCF;
}
printf STDERR "Read %d VCF files.\n", scalar(@id);

my $BED = 'ref.bed';
print STDERR "Creating BED file of all potential core SNPS: $BED\n";
open BED, '>', $BED or die "Unable to write/create '$BED'";
for my $seq (keys %snp) {
  for my $pos (sort { $a <=> $b } keys %{$snp{$seq}}) {
     print BED join("\t", $seq, $pos-1, $pos),"\n";
  }
}
close BED;

my $IDS = write_list( 'ids.txt', \@id );
my $FOF = write_list( 'bamfiles.txt', [ map { "$_.bam" } @id ] );

print STDERR "Checking depth/coreness of each SNP site...\n";
my %aln;

open COREBED, '>', "$output.bed" or die $!;
open COREGFF, '>', "$output.gff" or die $!;
print COREGFF "##gff-version 3\n";
for my $seq (keys %snp) {
  print COREGFF "##sequence-region $seq 1 99999999\n";
}

my $numcore=0;
open DEPTH, "samtools depth -b $BED -f bamfiles.txt |";
while (<DEPTH>) {
  my($seq,$pos,@cov) = split m/\t/;
  print STDERR "\rChecking: $seq $pos" if $verbose;
  if (any { $_ < $mindepth } @cov) {
    # only positions covered by ALL genomes will be potential 'core' sites   
    delete $snp{$seq}{$pos};
  }
  else {
    # possible core site, check if bases are all the same or not
    my $col = join( '', map { $snp{$seq}{$pos}{$_} || $snp{$seq}{$pos}{REF} } @id );
#    print STDERR "$pos: $col\n" if $verbose;
    my $same = substr($col,0,1)x(0+@id);
    if ( $col ne $same ) {    # col has all same chars?
      print STDERR "[CORE] $seq $pos: $col\n" if $verbose;
      for my $id (@id) {
        $aln{$id} .= ( $snp{$seq}{$pos}{$id} || $snp{$seq}{$pos}{REF} );
      }
      print COREBED join("\t", $seq, $pos-1, $pos),"\n";
      $numcore++;
      print COREGFF join("\t", $seq, 'wombac', 'variation', 
                               $pos, $pos, '.', '.', 0, 
                               sprintf("ID=SNP%06d", $numcore).";note=$col"
                        ),"\n";
    }
  }
}
unlink $BED, $FOF, $IDS;

print STDERR "\n" if $verbose;
if (not defined $aln{$id[0]}) {
  print STDERR "WARNING: No core SNPs found in: @id\n";  
  exit -1;
}

delete $aln{'ref'} if $noref;

printf STDERR "Found %d core SNPs from %d candidates.\n", 
  length($aln{$id[0]}), 
  $num_snps;

open COREALN, '>', "$output.aln" or die $!;
for my $id (@id) {
  print COREALN ">$id\n", $aln{$id}, "\n";
} 

#----------------------------------------------------------------------

sub write_list {
  my($filename, $list) = @_;
  print STDERR "Writing temporary file: $filename\n";
  open OUT, '>', $filename or die "Unable to create/write '$filename'";
  print OUT map { "$_\n" } @$list;
  close OUT;
  return $filename;
}

#----------------------------------------------------------------------
# Option setting routines

sub setOptions {
  use Getopt::Long;

  @Options = (
    {OPT=>"help",    VAR=>\&usage,             DESC=>"This help"},
    {OPT=>"verbose!",  VAR=>\$verbose, DEFAULT=>0, DESC=>"Verbose output"},
    {OPT=>"mindepth=i",  VAR=>\$mindepth, DEFAULT=>1, DESC=>"Minimum depth to count as covered"},
    {OPT=>"noref!",  VAR=>\$noref, DEFAULT=>0, DESC=>"Don't include reference in tree"},
    {OPT=>"output=s",  VAR=>\$output, DEFAULT=>'', DESC=>"Output prefix for .aln/.bed/.gff"},
  );

  (!@ARGV) && (usage());

  &GetOptions(map {$_->{OPT}, $_->{VAR}} @Options) || usage();

  # Now setup default values.
  foreach (@Options) {
    if (defined($_->{DEFAULT}) && !defined(${$_->{VAR}})) {
      ${$_->{VAR}} = $_->{DEFAULT};
    }
  }
}

sub usage {
  print "Usage: $0 [options] sample1 sample2 ...\n";
  print "(expects to be able to read sampleX.vcf and sampleX.bam\n";
  foreach (@Options) {
    printf "  --%-13s %s%s.\n",$_->{OPT},$_->{DESC},
           defined($_->{DEFAULT}) ? " (default '$_->{DEFAULT}')" : "";
  }
  exit(1);
}
 
#----------------------------------------------------------------------
